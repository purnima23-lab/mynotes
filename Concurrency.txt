JAVA CONCURRENCY::::::::::

thread safety:
Thread safe in java code refers to code which can be safely used in the multithreading environment and data will not be effected with that.

RACE condition in java:
As java supports multi threading feature , there are some scenarios where two or more thread can access the same shared resource and try to change it at the same time.
Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.
Problems often occur when one thread does a "check-then-act" (e.g. "check" if the value is X, then "act" to do something that depends on the value being X) and another thread does something to the value in between the "check" and the "act"
This can be avoided by using some sort lock mechanism on the shared resource.
two types of race conditions:
check-then-act
read-modify-write.

By using the synchronized keyword we can resolve the data inconsistency problem.but the main disadvantage of a synchronized is with this the thread waiting time increases and ultimately causes poor performance.

with synchronized only one thread can get execute the code at a time.
what are the common multi threading issues faced in java?

Atomic Integer:
in multi threaded environment when we need to perform some atomic operations on an int value without using sync keyword.
Atomic Integer is equally faster and more readable than performing the same using synchronization.

Atomic classes internally uses Compare - And - Swap (CAS) 
Atomic Integer - Integer
LongAdder - LongAdder
LongAccumulator n LongBinaryOperator - more genralized versions of LongAdder.

ConcurrentMap n ConcurrentHashMap - interfaces can be used.

Before java 8 Runnable interface - run()
From Java8 - Executors:
Executors - are capable of running asynchronous tasks and typically manages pool of threads 
Executor is a super interface and can be used to create threads simply by 
executor.execute() method.

sub interface:
ExecutorService extends Executor.

Future:
FutureTask:
Callable:
ExecutionException:
CompletableFuture
RunnableFuture
Volatile
ForkJoinFramework:

diff between ForkJoinFramework / ThreadExecutorService:

ForkJoinFramework is a specialized version over the ThreadExecutorService
and uses work-stealing algorithm where free threads can take the work from other worker who are busy.This improves the performance.

Fork-join breaks the taks into mini-tasks 
other difference is even though if we speicifed the intial thread pool capacity if it needed it can scale up the thread capacity any time.

one more difference is ForkJoinPoo threads are all daemon threads ence its pool doent have to be shutdown explicitly like executorService.shutdown 